-- Custom motorbike profile for OSRM with shipper feedback
-- Generated by Zone Service
-- Optimized for Vietnam traffic (no motorways, shipper ratings matter)

api_version = 4

properties.max_speed_for_map_matching = 140 / 3.6
properties.use_turn_restrictions = true
properties.continue_straight_at_waypoint = true
properties.weight_name = 'custom'

function setup()
  return {
    properties = properties,
    default_mode = mode.driving,
    default_speed = 35,     -- Realistic Saigon motorbike speed
    oneway_handling = true,
    turn_penalty = 4,       -- Motorbikes turn easier
    turn_bias = 1.05,
    u_turn_penalty = 10,    -- Lower than cars
  }
end

function process_way(profile, way, result, relations)
  local highway = way:get_value_by_key("highway")
  local name = way:get_value_by_key("name")
  local ref = way:get_value_by_key("ref")
  
  if not highway then
    return
  end
  
  -- Motorbikes CANNOT use motorways in Vietnam
  if highway == "motorway" or highway == "motorway_link" then
    return
  end
  
  local maxspeed = tonumber(way:get_value_by_key("maxspeed"))
  local custom_weight = tonumber(way:get_value_by_key("custom_weight"))
  local traffic_level = way:get_value_by_key("traffic_level")
  local congestion_score = tonumber(way:get_value_by_key("congestion_score"))
  
  -- SHIPPER FEEDBACK: Critical for Vietnam routing!
  -- Score 0-1: 0 = terrible road, 1 = excellent road
  local shipper_score = tonumber(way:get_value_by_key("shipper_score")) or 1.0
  
  -- Vietnam motorbike speed map (realistic)
  local speed_map = {
    trunk = 60,           -- Quốc lộ
    trunk_link = 40,
    primary = 50,         -- Đường chính
    primary_link = 30,
    secondary = 45,       -- Đường cấp 2
    secondary_link = 25,
    tertiary = 40,        -- Đường cấp 3
    tertiary_link = 20,
    residential = 30,     -- Đường dân cư
    service = 20,         -- Đường phụ
    unclassified = 25,    -- Đường nhỏ
    living_street = 15,   -- Đường nội bộ
    pedestrian = 10       -- Đường đi bộ (can ride slow)
  }
  
  local speed = speed_map[highway] or 25
  
  -- Respect maxspeed but don't exceed bike limits
  if maxspeed and maxspeed > 0 then
    speed = math.min(speed, maxspeed)
  end
  
  -- Apply traffic conditions
  if traffic_level then
    local traffic_multiplier = 1.0
    if traffic_level == "FREE_FLOW" then
      traffic_multiplier = 1.1
    elseif traffic_level == "NORMAL" then
      traffic_multiplier = 1.0
    elseif traffic_level == "SLOW" then
      traffic_multiplier = 0.7
    elseif traffic_level == "CONGESTED" then
      traffic_multiplier = 0.5   -- Bikes handle congestion slightly better
    elseif traffic_level == "BLOCKED" then
      traffic_multiplier = 0.2   -- Still some weaving ability
    end
    
    if congestion_score and congestion_score > 0 then
      local congestion_multiplier = math.max(0.2, 1.0 - (congestion_score / 100))
      traffic_multiplier = traffic_multiplier * congestion_multiplier
    end
    
    speed = speed * traffic_multiplier
  end
  
  -- Motorbikes generally follow oneway rules
  local oneway = way:get_value_by_key("oneway")
  if oneway == "yes" or oneway == "1" or oneway == "true" then
    result.forward_mode = mode.driving
    result.backward_mode = mode.inaccessible
  elseif oneway == "-1" or oneway == "reverse" then
    result.forward_mode = mode.inaccessible
    result.backward_mode = mode.driving
  else
    result.forward_mode = mode.driving
    result.backward_mode = mode.driving
  end
  
  result.forward_speed = speed
  result.backward_speed = speed
  
  -- Set name for OSRM to use in instructions
  if name then
    result.name = name
  elseif ref then
    result.name = ref
  end
  
  -- WEIGHT CALCULATION WITH SHIPPER FEEDBACK
  -- Lower shipper score = avoid this road = increase weight
  if custom_weight and custom_weight > 0 then
    -- Formula: bad roads (score 0.5) get 2x penalty, good roads (score 1.0) get no penalty
    -- Intuition: shipper_score 0.5 → penalty 1.5, shipper_score 0.3 → penalty 1.7
    local shipper_penalty = 2.0 - shipper_score
    local adjusted_weight = custom_weight * shipper_penalty
    
    local weight_duration = adjusted_weight * 60.0
    result.duration = weight_duration
    result.weight = adjusted_weight
  else
    result.duration = 0  -- OSRM will calc from speed
    result.weight = 0    -- OSRM will calc from speed
  end
end

function process_node(profile, node, result, relations)
  local traffic_signal = node:get_value_by_key("highway")
  if traffic_signal == "traffic_signals" then
    result.traffic_lights = true
  end
end

function process_turn(profile, turn)
  local angle = math.abs(turn.angle)
  if angle >= 170 and angle <= 190 then
    turn.duration = turn.duration + profile.u_turn_penalty
  elseif angle >= 45 then
    turn.duration = turn.duration + profile.turn_penalty
  end
end

return {
  setup = setup,
  process_way = process_way,
  process_node = process_node,
  process_turn = process_turn,
}
