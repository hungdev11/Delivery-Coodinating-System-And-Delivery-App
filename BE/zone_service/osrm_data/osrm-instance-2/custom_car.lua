-- Custom car profile for OSRM with dynamic weights
-- Generated by Zone Service

api_version = 4

properties.max_speed_for_map_matching = 180 / 3.6
properties.use_turn_restrictions = true
properties.continue_straight_at_waypoint = true
properties.weight_name = 'custom'

function setup()
  return {
    properties = properties,
    default_mode = mode.driving,
    default_speed = 30,
    oneway_handling = true,
    turn_penalty = 7.5,
    turn_bias = 1.075,
    u_turn_penalty = 20,
  }
end

function process_way(profile, way, result, relations)
  local highway = way:get_value_by_key("highway")
  local custom_weight = tonumber(way:get_value_by_key("custom_weight"))
  local traffic_level = way:get_value_by_key("traffic_level")
  local congestion_score = tonumber(way:get_value_by_key("congestion_score"))

  if not highway then
    return
  end

  -- Default speeds
  local speed_map = {
    motorway = 90,
    trunk = 70,
    primary = 60,
    secondary = 50,
    tertiary = 40,
    residential = 30,
    service = 20,
  }

  local speed = speed_map[highway] or 30
  local maxspeed = tonumber(way:get_value_by_key("maxspeed"))
  if maxspeed and maxspeed > 0 then
    speed = maxspeed
  end

  -- Apply traffic-based speed reduction
  if traffic_level then
    local traffic_multiplier = 1.0
    if traffic_level == "FREE_FLOW" then
      traffic_multiplier = 1.1  -- Slightly faster
    elseif traffic_level == "NORMAL" then
      traffic_multiplier = 1.0  -- Normal speed
    elseif traffic_level == "SLOW" then
      traffic_multiplier = 0.7  -- 30% slower
    elseif traffic_level == "CONGESTED" then
      traffic_multiplier = 0.4  -- 60% slower
    elseif traffic_level == "BLOCKED" then
      traffic_multiplier = 0.1  -- 90% slower
    end
    
    -- Apply congestion score if available
    if congestion_score and congestion_score > 0 then
      local congestion_multiplier = math.max(0.1, 1.0 - (congestion_score / 100))
      traffic_multiplier = traffic_multiplier * congestion_multiplier
    end
    
    speed = speed * traffic_multiplier
  end

  -- Handle oneway
  local oneway = way:get_value_by_key("oneway")
  if oneway == "yes" then
    result.forward_mode = mode.driving
    result.backward_mode = mode.inaccessible
  else
    result.forward_mode = mode.driving
    result.backward_mode = mode.driving
  end

  -- Set speed
  result.forward_speed = speed
  result.backward_speed = speed

  -- Apply custom weight (includes traffic conditions)
  if custom_weight and custom_weight > 0 then
    result.forward_rate = 60.0 / custom_weight
    result.backward_rate = 60.0 / custom_weight
    result.weight = custom_weight
  else
    result.forward_rate = speed
    result.backward_rate = speed
  end
end

function process_node(profile, node, result, relations)
  local traffic_signal = node:get_value_by_key("highway")
  if traffic_signal == "traffic_signals" then
    result.traffic_lights = true
  end
end

function process_turn(profile, turn)
  local angle = math.abs(turn.angle)
  if angle >= 170 and angle <= 190 then
    turn.duration = turn.duration + profile.u_turn_penalty
  elseif angle >= 45 then
    turn.duration = turn.duration + profile.turn_penalty
  end
end

return {
  setup = setup,
  process_way = process_way,
  process_node = process_node,
  process_turn = process_turn,
}
