-- Custom motorbike profile for OSRM with shipper feedback
-- Generated by Zone Service
-- Mode: BASE
-- Optimized for Vietnam traffic (no motorways, shipper ratings matter)

api_version = 4

properties.max_speed_for_map_matching = 140 / 3.6
properties.use_turn_restrictions = false  -- Vietnam motorbikes ignore most restrictions
properties.continue_straight_at_waypoint = true
properties.weight_name = 'custom'

function setup()
  return {
    properties = properties,
    default_mode = mode.driving,
    default_speed = 35,     -- Realistic Saigon motorbike speed
    oneway_handling = false, -- Allow motorbikes to reverse on non-critical oneways
    turn_penalty = 4,       -- Motorbikes turn easier
    turn_bias = 1.05,
    u_turn_penalty = 5,     -- Very low - motorbikes U-turn easily in Vietnam
    -- Mode flags
    strict_priority = false,
    use_delta = false,
    is_base = true,
  }
end

-- Base shipper feedback adjustment (always applies except base mode)
function apply_shipper_feedback(custom_weight, shipper_score, is_base)
  if is_base then
    return custom_weight
  end
  -- Score 0-1: 0 = terrible road, 1 = excellent road
  local shipper_penalty = 2.0 - shipper_score
  return custom_weight * shipper_penalty
end

-- Calculate weight adjustment based on mode
function calculate_weight_adjustment(custom_weight, speed, shipper_score, knp_point_score, knp_delta, knp_recommend_enabled, strict_priority, use_delta, is_base)
  local adjusted_weight = custom_weight or 1.0
  
  if not custom_weight or custom_weight <= 0 then
    return adjusted_weight
  end

  -- Step 1: Apply shipper feedback (except base)
  adjusted_weight = apply_shipper_feedback(adjusted_weight, shipper_score, is_base)

  -- Step 2: Base mode - only speed adjustment
  if is_base then
    local speed_factor = 1.0 - ((speed - 25) / 100)
    return adjusted_weight * speed_factor
  end

  -- Step 3: Point score and delta (if enabled)
  if use_delta then
    -- Apply point_score if recommend enabled
    if knp_point_score and knp_recommend_enabled ~= "0" then
      if strict_priority then
        -- STRICT PRIORITY: Maximum impact (prioritize quality over speed)
        -- High point_score (0.8-1.0) = reduce weight significantly (0.2-0.5x)
        -- Low point_score (0.0-0.5) = increase weight significantly (1.5-2.5x)
        local point_factor = 2.5 - (knp_point_score * 2.0)
        adjusted_weight = adjusted_weight * point_factor
      else
        -- FLEXIBLE PRIORITY: Moderate impact (balance quality and speed)
        -- Point score influences but speed can override if convenient
        local point_factor = 1.8 - (knp_point_score * 1.2)
        adjusted_weight = adjusted_weight * point_factor
      end
    end
    
    -- Apply delta (additive adjustment)
    if strict_priority then
      adjusted_weight = adjusted_weight + (knp_delta * 2.0)  -- Strong delta impact
    else
      adjusted_weight = adjusted_weight + knp_delta  -- Moderate delta impact
    end
  end

  -- Step 4: Speed adjustment (based on priority mode)
  if strict_priority then
    -- STRICT: Minimal speed influence (quality > speed)
    local speed_factor = 1.0 - ((speed - 25) / 150)  -- Very minimal
    adjusted_weight = adjusted_weight * speed_factor
  else
    -- FLEXIBLE: Moderate speed influence (speed can override if convenient)
    local speed_factor = 1.0 - ((speed - 25) / 60)  -- Stronger speed influence
    adjusted_weight = adjusted_weight * speed_factor
  end

  return adjusted_weight
end

function process_way(profile, way, result, relations)
  local highway = way:get_value_by_key("highway")
  local name = way:get_value_by_key("name")
  local ref = way:get_value_by_key("ref")

  if not highway then
    return
  end

  -- Motorbikes CANNOT use motorways in Vietnam
  if highway == "motorway" or highway == "motorway_link" then
    return
  end

  local maxspeed = tonumber(way:get_value_by_key("maxspeed"))
  local custom_weight = tonumber(way:get_value_by_key("custom_weight"))
  local traffic_level = way:get_value_by_key("traffic_level")
  local congestion_score = tonumber(way:get_value_by_key("congestion_score"))

  -- SHIPPER FEEDBACK: Critical for Vietnam routing!
  local shipper_score = tonumber(way:get_value_by_key("shipper_score")) or 1.0

  -- KNP OVERRIDES: Dynamic routing adjustments
  local knp_block_level = way:get_value_by_key("knp:block_level")
  local knp_delta = tonumber(way:get_value_by_key("knp:delta")) or 0
  local knp_point_score = tonumber(way:get_value_by_key("knp:point_score"))
  local knp_recommend_enabled = way:get_value_by_key("knp:recommend_enabled")
  local knp_soft_penalty = tonumber(way:get_value_by_key("knp:soft_penalty")) or 2.0
  local knp_min_penalty = tonumber(way:get_value_by_key("knp:min_penalty")) or 5.0

  -- Handle blocking (highest priority - ALWAYS applies)
  if knp_block_level == "hard" then
    return  -- Hard block: road is completely inaccessible
  end

  -- Vietnam motorbike speed map (realistic)
  local speed_map = {
    trunk = 60,           -- Quốc lộ
    trunk_link = 40,
    primary = 50,         -- Đường chính
    primary_link = 30,
    secondary = 45,       -- Đường cấp 2
    secondary_link = 25,
    tertiary = 40,        -- Đường cấp 3
    tertiary_link = 20,
    residential = 30,     -- Đường dân cư
    service = 20,         -- Đường phụ
    unclassified = 25,    -- Đường nhỏ
    living_street = 15,   -- Đường nội bộ
    pedestrian = 10       -- Đường đi bộ (can ride slow)
  }

  local speed = speed_map[highway] or 25

  -- Respect maxspeed but don't exceed bike limits
  if maxspeed and maxspeed > 0 then
    speed = math.min(speed, maxspeed)
  end

  -- Apply traffic conditions
  if traffic_level then
    local traffic_multiplier = 1.0
    if traffic_level == "FREE_FLOW" then
      traffic_multiplier = 1.1
    elseif traffic_level == "NORMAL" then
      traffic_multiplier = 1.0
    elseif traffic_level == "SLOW" then
      traffic_multiplier = 0.7
    elseif traffic_level == "CONGESTED" then
      traffic_multiplier = 0.5   -- Bikes handle congestion slightly better
    elseif traffic_level == "BLOCKED" then
      traffic_multiplier = 0.2   -- Still some weaving ability
    end

    if congestion_score and congestion_score > 0 then
      local congestion_multiplier = math.max(0.2, 1.0 - (congestion_score / 100))
      traffic_multiplier = traffic_multiplier * congestion_multiplier
    end

    speed = speed * traffic_multiplier
  end

  -- VIETNAM MOTORBIKE: More flexible oneway handling
  -- Motorbikes can often reverse on residential/service/unclassified roads
  local oneway = way:get_value_by_key("oneway")
  local allow_reverse = highway == "residential" or highway == "service" or 
                        highway == "unclassified" or highway == "living_street" or
                        highway == "tertiary" or highway == "tertiary_link"
  
  if oneway == "yes" or oneway == "1" or oneway == "true" then
    if allow_reverse then
      -- Allow reverse but with penalty (motorbikes do this in Vietnam)
      result.forward_mode = mode.driving
      result.backward_mode = mode.driving  -- Allow but penalized by weight
    else
      -- Major roads: respect oneway
      result.forward_mode = mode.driving
      result.backward_mode = mode.inaccessible
    end
  elseif oneway == "-1" or oneway == "reverse" then
    if allow_reverse then
      result.forward_mode = mode.driving  -- Allow but penalized
      result.backward_mode = mode.driving
    else
      result.forward_mode = mode.inaccessible
      result.backward_mode = mode.driving
    end
  else
    -- Bidirectional
    result.forward_mode = mode.driving
    result.backward_mode = mode.driving
  end

  result.forward_speed = speed
  result.backward_speed = speed

  -- Set name for OSRM to use in instructions
  if name then
    result.name = name
  elseif ref then
    result.name = ref
  end

  -- Calculate weight using mode-specific logic
  local adjusted_weight = calculate_weight_adjustment(
    custom_weight,
    speed,
    shipper_score,
    knp_point_score,
    knp_delta,
    knp_recommend_enabled,
    profile.strict_priority,
    profile.use_delta,
    profile.is_base
  )

  -- Apply blocking penalties (always applies except base)
  if not profile.is_base then
    if knp_block_level == "soft" then
      adjusted_weight = adjusted_weight * knp_soft_penalty
    elseif knp_block_level == "min" then
      adjusted_weight = adjusted_weight * knp_min_penalty
    end
    
    -- Penalty for reverse on oneway (only on minor roads where we allow it)
    if allow_reverse and (oneway == "yes" or oneway == "1" or oneway == "true" or oneway == "-1") then
      adjusted_weight = adjusted_weight * 1.3  -- 30% penalty for going wrong way
    end
  end

  -- Ensure minimum positive weight
  adjusted_weight = math.max(0.1, adjusted_weight)

  -- Set result
  if custom_weight and custom_weight > 0 then
    local weight_duration = adjusted_weight * 60.0
    result.duration = weight_duration
    result.weight = adjusted_weight
  else
    -- Fallback: use speed-based calculation
    result.duration = 0  -- OSRM will calc from speed
    result.weight = 0    -- OSRM will calc from speed
  end
end

function process_node(profile, node, result, relations)
  local traffic_signal = node:get_value_by_key("highway")
  if traffic_signal == "traffic_signals" then
    result.traffic_lights = true
  end
end

function process_turn(profile, turn)
  local angle = math.abs(turn.angle)
  
  -- Vietnam motorbikes: U-turns are very easy and common
  if angle >= 160 and angle <= 200 then
    -- U-turn: very low penalty for motorbikes
    turn.duration = turn.duration + profile.u_turn_penalty
    turn.weight = turn.weight + profile.u_turn_penalty
  elseif angle >= 45 then
    -- Regular turn
    turn.duration = turn.duration + profile.turn_penalty
    turn.weight = turn.weight + profile.turn_penalty
  end
end

return {
  setup = setup,
  process_way = process_way,
  process_node = process_node,
  process_turn = process_turn,
}
