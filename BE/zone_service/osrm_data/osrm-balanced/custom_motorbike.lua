-- Custom motorbike profile for OSRM with shipper feedback
-- Generated by Zone Service
-- Mode: BALANCED
-- Optimized for Vietnam traffic (no motorways, shipper ratings matter)

api_version = 4

properties.max_speed_for_map_matching = 140 / 3.6
properties.use_turn_restrictions = true
properties.continue_straight_at_waypoint = true
properties.weight_name = 'custom'

function setup()
  return {
    properties = properties,
    default_mode = mode.driving,
    default_speed = 35,     -- Realistic Saigon motorbike speed
    oneway_handling = true,
    turn_penalty = 4,       -- Motorbikes turn easier
    turn_bias = 1.05,
    u_turn_penalty = 10,    -- Lower than cars
  }
end

function process_way(profile, way, result, relations)
  local highway = way:get_value_by_key("highway")
  local name = way:get_value_by_key("name")
  local ref = way:get_value_by_key("ref")

  if not highway then
    return
  end

  -- Motorbikes CANNOT use motorways in Vietnam
  if highway == "motorway" or highway == "motorway_link" then
    return
  end

  local maxspeed = tonumber(way:get_value_by_key("maxspeed"))
  local custom_weight = tonumber(way:get_value_by_key("custom_weight"))
  local traffic_level = way:get_value_by_key("traffic_level")
  local congestion_score = tonumber(way:get_value_by_key("congestion_score"))

  -- SHIPPER FEEDBACK: Critical for Vietnam routing!
  -- Score 0-1: 0 = terrible road, 1 = excellent road
  local shipper_score = tonumber(way:get_value_by_key("shipper_score")) or 1.0

  -- KNP OVERRIDES: Dynamic routing adjustments
  local knp_block_level = way:get_value_by_key("knp:block_level")
  local knp_delta = tonumber(way:get_value_by_key("knp:delta")) or 0
  local knp_point_score = tonumber(way:get_value_by_key("knp:point_score"))
  local knp_recommend_enabled = way:get_value_by_key("knp:recommend_enabled")
  local knp_soft_penalty = tonumber(way:get_value_by_key("knp:soft_penalty")) or 2.0
  local knp_min_penalty = tonumber(way:get_value_by_key("knp:min_penalty")) or 5.0

  -- Handle blocking (highest priority)
  if knp_block_level == "hard" then
    -- Hard block: road is completely inaccessible
    return
  end

  -- Vietnam motorbike speed map (realistic)
  local speed_map = {
    trunk = 60,           -- Quốc lộ
    trunk_link = 40,
    primary = 50,         -- Đường chính
    primary_link = 30,
    secondary = 45,       -- Đường cấp 2
    secondary_link = 25,
    tertiary = 40,        -- Đường cấp 3
    tertiary_link = 20,
    residential = 30,     -- Đường dân cư
    service = 20,         -- Đường phụ
    unclassified = 25,    -- Đường nhỏ
    living_street = 15,   -- Đường nội bộ
    pedestrian = 10       -- Đường đi bộ (can ride slow)
  }

  local speed = speed_map[highway] or 25

  -- Respect maxspeed but don't exceed bike limits
  if maxspeed and maxspeed > 0 then
    speed = math.min(speed, maxspeed)
  end

  -- Apply traffic conditions
  if traffic_level then
    local traffic_multiplier = 1.0
    if traffic_level == "FREE_FLOW" then
      traffic_multiplier = 1.1
    elseif traffic_level == "NORMAL" then
      traffic_multiplier = 1.0
    elseif traffic_level == "SLOW" then
      traffic_multiplier = 0.7
    elseif traffic_level == "CONGESTED" then
      traffic_multiplier = 0.5   -- Bikes handle congestion slightly better
    elseif traffic_level == "BLOCKED" then
      traffic_multiplier = 0.2   -- Still some weaving ability
    end

    if congestion_score and congestion_score > 0 then
      local congestion_multiplier = math.max(0.2, 1.0 - (congestion_score / 100))
      traffic_multiplier = traffic_multiplier * congestion_multiplier
    end

    speed = speed * traffic_multiplier
  end

  -- Motorbikes generally follow oneway rules
  local oneway = way:get_value_by_key("oneway")
  if oneway == "yes" or oneway == "1" or oneway == "true" then
    result.forward_mode = mode.driving
    result.backward_mode = mode.inaccessible
  elseif oneway == "-1" or oneway == "reverse" then
    result.forward_mode = mode.inaccessible
    result.backward_mode = mode.driving
  else
    result.forward_mode = mode.driving
    result.backward_mode = mode.driving
  end

  result.forward_speed = speed
  result.backward_speed = speed

  -- Set name for OSRM to use in instructions
  if name then
    result.name = name
  elseif ref then
    result.name = ref
  end

  -- WEIGHT CALCULATION WITH SHIPPER FEEDBACK AND KNP OVERRIDES
  -- Lower shipper score = avoid this road = increase weight
  if custom_weight and custom_weight > 0 then
    -- Formula: bad roads (score 0.5) get 2x penalty, good roads (score 1.0) get no penalty
    -- Intuition: shipper_score 0.5 → penalty 1.5, shipper_score 0.3 → penalty 1.7
    local shipper_penalty = 2.0 - shipper_score
    local adjusted_weight = custom_weight * shipper_penalty

    -- Apply KNP adjustments
    -- 1. Point score (0-1): higher = better road, reduce weight
    if knp_point_score and knp_recommend_enabled ~= "0" then
      local point_factor = 2.0 - knp_point_score  -- 1.0 = neutral, 0.5 for score=1.0, 1.5 for score=0.5
      adjusted_weight = adjusted_weight * point_factor
    end

    -- 2. Delta: direct additive adjustment
    adjusted_weight = adjusted_weight + knp_delta

    -- 3. Blocking penalties
    if knp_block_level == "soft" then
      adjusted_weight = adjusted_weight * knp_soft_penalty
    elseif knp_block_level == "min" then
      adjusted_weight = adjusted_weight * knp_min_penalty
    end

    -- Ensure minimum positive weight
    adjusted_weight = math.max(0.1, adjusted_weight)

    local weight_duration = adjusted_weight * 60.0
    result.duration = weight_duration
    result.weight = adjusted_weight
  else
    result.duration = 0  -- OSRM will calc from speed
    result.weight = 0    -- OSRM will calc from speed
  end
end

function process_node(profile, node, result, relations)
  local traffic_signal = node:get_value_by_key("highway")
  if traffic_signal == "traffic_signals" then
    result.traffic_lights = true
  end
end

function process_turn(profile, turn)
  local angle = math.abs(turn.angle)
  if angle >= 170 and angle <= 190 then
    turn.duration = turn.duration + profile.u_turn_penalty
  elseif angle >= 45 then
    turn.duration = turn.duration + profile.turn_penalty
  end
end

return {
  setup = setup,
  process_way = process_way,
  process_node = process_node,
  process_turn = process_turn,
}
