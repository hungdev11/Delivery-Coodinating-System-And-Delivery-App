name: Secret Scanning and Security Checks

on:
  pull_request:
    branches: [ "main", "develop" ]
  push:
    branches: [ "main", "develop" ]
  workflow_dispatch:

jobs:
  # Job 1: Secret Scanning (BLOCKS PR if secrets found)
  secret-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      security-events: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better detection

      - name: Run TruffleHog Secret Scanner
        uses: trufflesecurity/trufflehog@main
        continue-on-error: true
        id: trufflehog
        with:
          path: ./
          base: ${{ github.event.pull_request.base.sha || github.event.before }}
          head: ${{ github.event.pull_request.head.sha || github.sha }}
          extra_args: --only-verified --json

      - name: Run Gitleaks Secret Scanner
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
        with:
          config-path: .gitleaks.toml
          no-banner: true
          redact: true
          exit-code: 1  # Fail if secrets found
        id: gitleaks

      - name: Check for common secrets patterns
        id: secret-check
        run: |
          echo "Scanning for common secret patterns..."
          
          # Check if Gitleaks found secrets
          GITLEAKS_FAILED=false
          TRUFFLEHOG_FAILED=false
          if [ "${{ steps.gitleaks.outcome }}" == "failure" ]; then
            echo "âš ï¸ Gitleaks detected secrets!"
            GITLEAKS_FAILED=true
          fi
          if [ "${{ steps.trufflehog.outcome }}" == "failure" ]; then
            echo "âš ï¸ TruffleHog detected secrets!"
            TRUFFLEHOG_FAILED=true
          fi
          
          # Patterns to detect (excluding environment variable templates)
          PATTERNS=(
            "AKIA[0-9A-Z]{16}"                    # AWS Access Key
            "sk_live_[0-9a-zA-Z]{24,}"           # Stripe Live Key
            "sk_test_[0-9a-zA-Z]{24,}"           # Stripe Test Key
            "AIza[0-9A-Za-z_-]{35}"               # Google API Key
            "ghp_[0-9a-zA-Z]{36}"                 # GitHub Personal Access Token
            "gho_[0-9a-zA-Z]{36}"                 # GitHub OAuth Token
            "ghu_[0-9a-zA-Z]{36}"                 # GitHub User Token
            "ghs_[0-9a-zA-Z]{36}"                 # GitHub Server Token
            "ghr_[0-9a-zA-Z]{36}"                 # GitHub Refresh Token
            "xox[baprs]-[0-9a-zA-Z-]{10,48}"     # Slack Token
            "xoxp-[0-9a-zA-Z-]{10,}"             # Slack Bot Token
            "-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----"  # Private Keys
            "-----BEGIN PGP PRIVATE KEY BLOCK-----"              # PGP Private Key
            "password\s*[=:]\s*['\"]?[a-zA-Z0-9]{8,}"            # Hardcoded passwords (but exclude env vars)
            "api[_-]?key\s*[=:]\s*['\"]?[a-zA-Z0-9]{20,}"       # API Keys (but exclude env vars)
            "secret[_-]?key\s*[=:]\s*['\"]?[a-zA-Z0-9]{20,}"     # Secret Keys (but exclude env vars)
            "access[_-]?token\s*[=:]\s*['\"]?[a-zA-Z0-9]{20,}"   # Access Tokens (but exclude env vars)
            # Database URLs - only match REAL credentials, NOT environment variable templates
            # Pattern excludes: ${VAR}, $VAR, process.env.VAR
            # This pattern is complex - we'll filter env vars in post-processing instead
            "(mysql|postgres|mongodb|redis)://[^:]+:[^@]+@[^/]+"  # Will filter env vars later
          )
          
          SECRETS_FOUND=0
          FILES_WITH_SECRETS=()
          
          # Exclude common false positives and configuration files
          EXCLUDE_PATTERNS=(
            "node_modules"
            ".git"
            "dist"
            "build"
            "target"
            ".gradle"
            ".idea"
            "*.lock"
            "package-lock.json"
            "yarn.lock"
            "*.log"
            ".env.example"
            ".env.template"
            "env.local"
            "*.md"
            "*.txt"
            "LICENSE"
            ".github"
            ".gitleaks.toml"
            "secret-scan.yml"
            "docker-compose"
            "application.yaml"
            "application.yml"
            "config.ts"
            "KeycloakInitConfig.java"
            "LoginActivity.java"
            "model.type.ts"
          )
          
          # Additional filter: Exclude matches that contain environment variable syntax
          EXCLUDE_ENV_VAR_PATTERNS=(
            "\$\{"
            "\$[A-Z_]+"
            "process\.env"
            "processEnv"
            "env\."
            "ENV\["
          )
          
          # Build exclude string for grep
          EXCLUDE_STRING=$(IFS='|'; echo "${EXCLUDE_PATTERNS[*]}")
          
          for pattern in "${PATTERNS[@]}"; do
            echo "Checking pattern: ${pattern:0:30}..."
            # Use grep to find matches, excluding common directories
            MATCHES=$(grep -r -E "$pattern" . 2>/dev/null | grep -vE "$EXCLUDE_STRING" || true)
            
            # Filter out environment variable templates
            if [ -n "$MATCHES" ]; then
              FILTERED_MATCHES=""
              while IFS= read -r line; do
                # Skip if line contains environment variable syntax
                SKIP_LINE=false
                for env_pattern in "${EXCLUDE_ENV_VAR_PATTERNS[@]}"; do
                  if echo "$line" | grep -qE "$env_pattern"; then
                    SKIP_LINE=true
                    break
                  fi
                done
                
                if [ "$SKIP_LINE" = false ]; then
                  if [ -z "$FILTERED_MATCHES" ]; then
                    FILTERED_MATCHES="$line"
                  else
                    FILTERED_MATCHES="$FILTERED_MATCHES"$'\n'"$line"
                  fi
                fi
              done <<< "$MATCHES"
              
              if [ -n "$FILTERED_MATCHES" ]; then
                echo "âš ï¸ SECRET DETECTED with pattern: ${pattern:0:30}"
                echo "$FILTERED_MATCHES" | head -5
                SECRETS_FOUND=$((SECRETS_FOUND + 1))
                
                # Extract file names
                while IFS= read -r line; do
                  FILE=$(echo "$line" | cut -d: -f1)
                  if [[ ! " ${FILES_WITH_SECRETS[@]} " =~ " ${FILE} " ]]; then
                    FILES_WITH_SECRETS+=("$FILE")
                  fi
                done <<< "$FILTERED_MATCHES"
              fi
            fi
          done
          
          # Check if Gitleaks or pattern matching found secrets
          if [ "$GITLEAKS_FAILED" = true ] || [ "$TRUFFLEHOG_FAILED" = true ] || [ $SECRETS_FOUND -gt 0 ]; then
            echo "secrets_found=true" >> $GITHUB_OUTPUT
            echo "files_count=${#FILES_WITH_SECRETS[@]}" >> $GITHUB_OUTPUT
            echo "files=${FILES_WITH_SECRETS[*]}" >> $GITHUB_OUTPUT
            echo "::error::ðŸš¨ SECRETS DETECTED!"
            if [ "$GITLEAKS_FAILED" = true ]; then
              echo "Gitleaks scanner found secrets!"
            fi
            if [ "$TRUFFLEHOG_FAILED" = true ]; then
              echo "TruffleHog scanner found secrets!"
            fi
            if [ $SECRETS_FOUND -gt 0 ]; then
              echo "Found $SECRETS_FOUND potential secrets in ${#FILES_WITH_SECRETS[@]} file(s)"
              if [ ${#FILES_WITH_SECRETS[@]} -gt 0 ]; then
                echo "Files with secrets:"
                printf '%s\n' "${FILES_WITH_SECRETS[@]}"
              fi
            fi
            exit 1
          else
            echo "secrets_found=false" >> $GITHUB_OUTPUT
            echo "âœ… No secrets detected"
          fi

      - name: Comment on PR if secrets found
        if: github.event_name == 'pull_request' && steps.secret-check.outputs.secrets_found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const files = '${{ steps.secret-check.outputs.files }}'.split(' ');
            const filesCount = '${{ steps.secret-check.outputs.files_count }}';
            
            const body = `## ðŸš¨ Security Alert: Secrets Detected
            
            **This PR has been blocked due to detected secrets in the codebase.**
            
            **Files with potential secrets:** ${filesCount}
            
            Please review and remove any hardcoded secrets, API keys, passwords, or tokens from the code.
            
            **Next steps:**
            1. Remove all hardcoded secrets from the code
            2. Use environment variables or secrets management instead
            3. Add the files to \`.gitignore\` if they contain sensitive data
            4. Push a new commit to trigger re-scanning
            
            **Detected files:**
            \`\`\`
            ${files.join('\n')}
            \`\`\`
            
            âš ï¸ **This PR cannot be merged until all secrets are removed.**`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Fail workflow if secrets found
        if: steps.secret-check.outputs.secrets_found == 'true'
        run: |
          echo "::error::PR BLOCKED: Secrets detected in codebase. Please remove all secrets before merging."
          exit 1

  # Job 2: Dependency Vulnerability Scanning
  dependency-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Job 3: Code Security Analysis
  code-security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run Semgrep Security Scan
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten
          # Note: SARIF generation may not be available in v1, results are shown in workflow logs
